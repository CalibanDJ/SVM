import os
import sys
import copy
import math
import argparse
import numpy as np
#import cv2
import matplotlib.pyplot as plt
from matplotlib import cm
from skimage import io, feature, color, transform
from PIL import Image
from PIL import ImageEnhance

"""
Open the image file associated to the path given
"""
def read_image(path):
    image = io.imread(path)
    return image


"""
Function that return the best three orthogonal vanishing points, the lines associated and the edges related
"""

def get_vp_inliers(image, contrast, sharpness, sigma, iterations, line_len, line_gap, threshold):
    #Enhance image in order to detect more easily the edges and lines
    image_pil = Image.fromarray(image)
    enhanced_pil = image_enhance(image_pil, contrast=contrast, sharpness=sharpness)
    enhanced_ski = np.array(enhanced_pil)
    edges = get_canny_edges(enhanced_ski, sigma=sigma)
    lines = get_hough_lines(edges, line_length=line_len, line_gap=line_gap)

    #extract the first vanishing poin then remove the lines corresponding
    best_hypothesis_1, best_inliers_1 = run_line_ransac(lines, iterations, threshold)
    ignore_pts = best_inliers_1

    #extract the second best vanishin point
    best_hypothesis_2, best_inliers_2 = run_line_ransac(lines, iterations, threshold, ignore_pts=ignore_pts)
    ignore_pts = np.logical_or(best_inliers_1, best_inliers_2)

    #extract the third vanishing point
    best_hypothesis_3, best_inliers_3 = run_line_ransac(lines, iterations, threshold, ignore_pts=ignore_pts)
    inlier_lines_list = [best_inliers_1, best_inliers_2, best_inliers_3]

    best_hypothesis_1 = best_hypothesis_1 / best_hypothesis_1[-1]
    best_hypothesis_2 = best_hypothesis_2 / best_hypothesis_2[-1]
    best_hypothesis_3 = best_hypothesis_3 / best_hypothesis_3[-1]
    hypothesis_list = [best_hypothesis_1, best_hypothesis_2, best_hypothesis_3]
    viz_stuff = [image, enhanced_ski, edges, lines]
    return inlier_lines_list, hypothesis_list, viz_stuff

def image_enhance(image, contrast, sharpness):
    img_contrast = ImageEnhance.Contrast(image)
    image_contrasted = img_contrast.enhance(contrast)
    img_sharp = ImageEnhance.Sharpness(image_contrasted)
    image_sharped = img_sharp.enhance(sharpness)
    return image_sharped

"""
Detect edges thank to canny
"""
def get_canny_edges(image, sigma):
    edges = feature.canny(color.rgb2gray(image), sigma=sigma)
    return edges

"""
Compute line from edges
"""
def get_hough_lines(edges, line_length, line_gap):
    lines = transform.probabilistic_hough_line(edges, line_length=line_length, line_gap=line_gap)
    return np.asarray(lines)

"""
Save image with lines and edges
"""
def visualize_inliers(image, enhanced, edges, lines, inlier_lines_list, colors, fig_name='detected_lines.png'):
    
    subplot_count = len(inlier_lines_list) + 3

    fig, axes = plt.subplots(3, subplot_count-3, figsize=(15, 15), sharex=True, sharey=True)
    ax = axes.ravel()

    ax[0].imshow(image)
    ax[0].set_title('Input image')
    
    ax[2].imshow(enhanced)
    ax[2].set_title('Enhanced image')
    
    ax[3].imshow(edges)
    ax[3].set_title('Canny edges')

    ax[5].imshow(edges * 0)
    for line in lines:
        p0, p1 = line
        ax[5].plot((p0[0], p1[0]), (p0[1], p1[1]))
    ax[5].set_xlim((0, image.shape[1]))
    ax[5].set_ylim((image.shape[0], 0))
    ax[5].set_title('Probabilistic Hough')
    
    for i in range(len(inlier_lines_list)):
        ax[i+6].imshow(edges * 0)
        for line in lines[inlier_lines_list[i]]:
            p0, p1 = line
            ax[i+6].plot((p0[0], p1[0]), (p0[1], p1[1]), colors[i])
        ax[i+6].set_xlim((0, image.shape[1]))
        ax[i+6].set_ylim((image.shape[0], 0))
        ax[i+6].set_title('RANSAC {} Inliers'.format(str(i)))

    for a in ax:
        a.set_axis_off()

    plt.tight_layout()
    plt.savefig(fig_name)
    plt.close()
"""
Save images with vanishing poin and lines
"""
def visualize_vanishing_points(vp1, vp2, vp3, image, lines, edges, inlier_lines_list, colors, fig_name):
    #3 most significant vanishing points
    vps = [vp1, vp2, vp3]

    #Create a figure for each VP
    for i in range(len(inlier_lines_list)):
        plt.imshow(image)
        #Draw each line of VP with specific color
        for line in lines[inlier_lines_list[i]]:
            p0, p1 = line
            plt.plot((p0[0], p1[0]), (p0[1], p1[1]), colors[i])

        plt.plot([vps[i][0]], [vps[i][1]], colors[i]+'X', markersize=5)
        plt.axis('off')
        plt.tight_layout()
        plt.savefig("." + fig_name.split('.')[1] + "_vp" + str(i) + '.png') 
        plt.close()

    #Create a figure with the 3 VP
    plt.imshow(image)
    for i in range(len(inlier_lines_list)):
        #Add all lines of the vp
        for line in lines[inlier_lines_list[i]]:
            p0, p1 = line
            plt.plot((p0[0], p1[0]), (p0[1], p1[1]), colors[i])

    #Add the 3 VP
    plt.plot([vps[0][0]], [vps[0][1]], colors[0]+'X', markersize=5)
    plt.plot([vps[1][0]], [vps[1][1]], colors[1]+'X', markersize=5)
    plt.plot([vps[2][0]], [vps[2][1]], colors[2]+'X', markersize=5)
    plt.axis('off')
    plt.tight_layout()
    plt.savefig(fig_name) 
    plt.close() 

def storage_calibration_result(vp1, vp2, vp3, forcal, M_r_o2c, V_t_o2c, img_name):
    vps = [vp1, vp2, vp3]
    with open("./RunResult/" + str(img_name) + 'CalibrationResult.txt', "w") as f:
        f.write("-----------Vanishing Points (in pixel)-----------")
        for i in range(len(vps)):
            f.write("\n")
            f.write("vp" + str(i) + ":\r")
            f.write("x: " + str(vps[i][0]))
            f.write("\r")
            f.write("y: " + str(vps[i][1]))
            # f.write("\n")
        f.write("\n")
        f.write("\n")
        f.write("-----------Forcal (in pixel)-----------")
        for i in range(len(forcal)):
            f.write("\n")
            f.write("f" + str(i) + ":\r" + str(forcal[i]))
            f.write("\n")
        f.write("\n")
        f.write("-----------Rotation Matrix (from o to c)-----------")
        for i in range(len(M_r_o2c)):
            f.write("\n")
            f.write("r" + str(i) + ":\n" + str(M_r_o2c[i]))
            f.write("\n")
            euler = rotationmatrix_2_eulerangles(M_r_o2c[i])
            f.write("euler" + str(i) + ":\n" + str(euler))
            f.write("\n")
        f.write("\n")    
        f.write("-----------Translation Vector (in meter)-----------")
        for i in range(len(V_t_o2c)):
            f.write("\n")
            f.write("t" + str(i) + ":\n" + str(V_t_o2c[i]))
            f.write("\n")
        f.close()
    print("Finish Calibration!")

"""
Camera Calibration.
"""



"""
Vanishing Point Detection.
"""
def calculate_metric_angle(current_hypothesis, lines, ignore_pts, ransac_angle_thresh):
    current_hypothesis = current_hypothesis / current_hypothesis[-1]
    hypothesis_vp_direction = current_hypothesis[:2] - lines[:,0]
    lines_vp_direction = lines[:,1] - lines[:,0]
    magnitude = np.linalg.norm(hypothesis_vp_direction, axis=1) * np.linalg.norm(lines_vp_direction, axis=1)
    magnitude[magnitude == 0] = 1e-5
    cos_theta = (hypothesis_vp_direction*lines_vp_direction).sum(axis=-1) / magnitude
    theta = np.arccos(np.abs(cos_theta))
    inliers = (theta < ransac_angle_thresh * np.pi / 180)
    inliers[ignore_pts] = False
    return inliers, inliers.sum()

def run_line_ransac(lines, ransac_iter, ransac_angle_thresh, ignore_pts=None):
    best_vote_count = 0
    best_inliers = None
    best_hypothesis = None
    if ignore_pts is None:
        ignore_pts = np.zeros((lines.shape[0])).astype('bool')
        lines_to_chose = np.arange(lines.shape[0])
    else:
        lines_to_chose = np.where(ignore_pts==0)[0]
    for iter_count in range(ransac_iter):
        idx1, idx2 = np.random.choice(lines_to_chose, 2, replace=False)
        l1 = np.cross(np.append(lines[idx1][1], 1), np.append(lines[idx1][0], 1))
        l2 = np.cross(np.append(lines[idx2][1], 1), np.append(lines[idx2][0], 1))

        current_hypothesis = np.cross(l1, l2)
        if current_hypothesis[-1] == 0:
            continue
        inliers, vote_count = calculate_metric_angle(current_hypothesis, lines, ignore_pts, ransac_angle_thresh)
        if vote_count > best_vote_count:
            best_vote_count = vote_count
            best_hypothesis = current_hypothesis
            best_inliers = inliers
    return best_hypothesis, best_inliers



def findProjectionMatrix(vx, vy, vz, o, rx, ry, rz):
        proj_matrix = np.stack(
            [vx, vy, vz, o], axis=1)
        # Now we'll find the scales associated to x, y and z
    
        ref_lengthx = np.linalg.norm(rx - o.reshape(-1, 1))
        ax, _, _, _ = np.linalg.lstsq(vx.reshape(-1, 1) - rx, rx - o.reshape(-1, 1))
        scalesx = ax[0, 0] / ref_lengthx
        
        ref_lengthy = np.linalg.norm(ry - o.reshape(-1, 1))
        ay, _, _, _ = np.linalg.lstsq(vy.reshape(-1, 1) - ry, (ry - o.reshape(-1, 1)))
        scalesy = ay[0, 0] / ref_lengthy

        ref_lengthz = np.linalg.norm(rz - o.reshape(-1, 1))
        az, _, _, _ = np.linalg.lstsq(vz.reshape(-1, 1) - rz, (rz - o.reshape(-1, 1)))
        scalesz = az[0, 0] / ref_lengthz


        # Use the scales to get the correct matrix
        proj_matrix[:, 0] = proj_matrix[:, 0] * scalesx
        proj_matrix[:, 1] = proj_matrix[:, 1] * scalesy
        proj_matrix[:, 2] = proj_matrix[:, 2] * scalesz
        return proj_matrix

def getTextureMap(image, pts, proj_matrix) :

    #Planar perspective Map
    homography_xy = proj_matrix[:, [0, 1, 3]].copy()
    homography_yz = proj_matrix[:, [1, 2, 3]].copy()
    homography_xz = proj_matrix[:, [0, 2, 3]].copy()

    #Warp image with homography
    warped_xy = transform.warp(image, homography_xy)
    warped_yz = transform.warp(image, homography_yz)
    warped_xz = transform.warp(image, homography_xz)

    #Save image
    io.imsave("warped_xy.png", warped_xy)
    io.imsave("warped_yz.png", warped_yz)
    io.imsave("warped_xz.png", warped_xz)

    return True
    

def sort_vp(vps) :
    vpx = 0
    vpy = 0
    vpz = 0

    for i in range(3):
        if (vps[i][0] > vps[vpx][0]):
            vpx = i

    for i in range(3):
        if (vps[i][0] < vps[vpz][0]):
            vpz = i

    vpy = 3 - (vpx + vpz)
            
    return vps[vpx], vps[vpy], vps[vpz]
"""
Main.
"""
def main(image_path, puv, px, py, pz, contrast=5, sharpness=10, sigma=5, iterations=3000, line_len=11, line_gap=7, threshold: 'float' = 2):
    #Get image info
    img_name = os.path.basename(image_path).split('.')[0]
    image = read_image(image_path)
    
    #Compute vanishing points and lines 
    inlier_lines_list, hypothesis_list, viz_stuff = get_vp_inliers(image, contrast, sharpness, sigma, iterations, line_len, line_gap, threshold)

    #Display Lines and VP
    image, enhanced_ski, edges, lines = viz_stuff
    best_hypothesis_1, best_hypothesis_2, best_hypothesis_3 = hypothesis_list
    fig_name = "./RunResult/"+'{}_inliers.png'\
                .format(img_name)
    colors_vp = ['r', 'g', 'b']
    visualize_inliers(image, enhanced_ski, edges, lines, inlier_lines_list, colors_vp, fig_name=fig_name)

    vps = [best_hypothesis_1, best_hypothesis_2, best_hypothesis_3]

    vpx, vpy, vpz = sort_vp(vps)
    
    fig_name = "./RunResult/"+'{}_vanishing_point.png'\
                .format(img_name)
    visualize_vanishing_points(vpx, vpy, vpz,
                               image, lines, edges, inlier_lines_list, colors_vp, fig_name)

  
    proj = findProjectionMatrix(
        np.array([vpx[0], vpx[1], 1]),
        np.array([vpy[0], vpy[1], 1]),
        np.array([vpz[0], vpz[1], 1]),
                            np.array([puv[0], puv[1], 1]),
                            np.array([px[0], px[1], 1]).reshape(-1, 1),
                            np.array([py[0], py[1], 1]).reshape(-1, 1),
                            np.array([pz[0], pz[1], 1]).reshape(-1, 1))
    print(proj)
    #storage_calibration_result(best_hypothesis_1, best_hypothesis_2, best_hypothesis_3, forcal, M
    getTextureMap(image, True, proj)
    return True
    

